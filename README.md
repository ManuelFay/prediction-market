# Prediction Market Prototype

A minimal FastAPI backend that implements the LMSR-style AMM described in the spec: users get starting balances, can create binary markets with seeded liquidity, place 1€ bets, and resolve/complain on outcomes. Data persists to a local SQLite database.

## Quickstart

1. **Install dependencies**
   ```bash
   python -m venv .venv
   source .venv/bin/activate
   pip install -r requirements.txt
   ```
2. **Run the API**
   ```bash
   uvicorn app.main:app --reload
   ```
3. **Try it out**
   Open the autogenerated docs at http://localhost:8000/docs.

## Key API flows

- **Create a user** (gets 50€ balance): `POST /users` with `{ "name": "alice" }`.
- **Create a market**: `POST /markets?user_id=<creatorId>` with `MarketCreate` payload. The creator is debited 10€ to seed the AMM. Use `liquidity_b` to tune price sensitivity.
- **Place a bet**: `POST /markets/{id}/bet?user_id=<id>` with `{ "side": "YES" | "NO" }` for a fixed 1€ stake. Rate limited to one bet per market every 5 seconds globally.
- **Check markets**: `GET /markets` or `GET /markets/{id}` for prices, odds, and bets.
- **Resolve**: `POST /markets/{id}/resolve` with `{ "outcome": "YES" | "NO" | "INVALID" }`. Winners are paid `shares * 1€`; invalid markets refund all stakes and return the seed.
- **Complaints**: `POST /markets/{id}/complain` while status is `PENDING` to log disputes.
- **Ledger**: `GET /users/{id}/ledger` shows `STARTING_BALANCE`, `DEPOSIT_SEED`, `BET_DEBIT`, `PAYOUT`, and `REFUND` entries.

## AMM implementation notes

- Uses the LMSR cost function with configurable `b`. Initial `q_yes/q_no` are set so the price matches the creator's probability and the AMM is pre-loaded with a 10€ subsidy (shifted equally across quantities).
- Each 1€ bet solves for the share delta such that `C(q') - C(q) = 1`. Stored shares lock in the payoff; displayed odds are `shares / stake`.
- Prices are always derived from current `q` via LMSR and exposed as `price_yes`/`price_no` on market reads.

## Frontend suggestion

For a lightweight UI, run the FastAPI docs or pair this backend with a small React/Vite single-page app that calls these endpoints; host both on services like Render/Fly.io with SQLite persisted to disk or swapped for Postgres.
