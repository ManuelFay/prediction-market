# Prediction Market Prototype

A minimal FastAPI backend and lightweight browser frontend that implements the LMSR-style AMM described in the spec: users get starting balances, can create binary markets with seeded liquidity, place 1€ bets, and resolve/complain on outcomes. Data persists to a local SQLite database.

For a walkthrough of common flows, see [USER_GUIDE.md](USER_GUIDE.md).
For a deep dive into pricing math and guardrails, read [docs/odds.md](docs/odds.md).

## Quickstart

1. **Install dependencies**
   ```bash
   python -m venv .venv
   source .venv/bin/activate
   pip install -r requirements.txt
   ```
2. **Install frontend deps (Node 24+)**
   ```bash
   cd app/frontend
   npm install
   ```
3. **Run the API + frontend**
   ```bash
   uvicorn app.main:app --reload
   ```
   - Frontend (Vite dev server) in another terminal for faster reloads:
     ```bash
     cd app/frontend
     npm run dev -- --host
     ```
     Set `VITE_API_BASE_URL=http://localhost:8000` in `.env.local` (or export) when using the dev server.
   - For a single-process run, build the frontend then start the API (it serves `app/frontend/dist`):
     ```bash
     cd app/frontend && npm run build
     cd ../..
     uvicorn app.main:app --reload
     ```
3. **Try it out**
   - Browser UI at http://localhost:8000/
   - Autogenerated docs at http://localhost:8000/docs

## Deployment

The app ships a Dockerfile so you can run the API + static frontend in a single
container. The server listens on port `8000` and binds to `0.0.0.0` by default.

### Configuration

- `DATABASE_URL` (optional): defaults to `sqlite:///./data/prediction.db`. Point
  this to a persistent path (e.g., `/data/prediction.db` when mounting a
  volume) or to Postgres if you migrate the models.
- `RESET_DB_ON_STARTUP` (optional): defaults to `false` so production data
  survives restarts. Set to `true` for ephemeral/local testing if you want a
  clean schema on each boot.

### Run with Docker locally

```bash
docker build -t prediction-market .
docker run --rm -p 8000:8000 prediction-market
```

Visit http://localhost:8000/ for the UI and http://localhost:8000/docs for API
docs.

### Deploy to Fly.io

1. Install the Fly CLI and log in: `flyctl auth login`.
2. Ensure your app name matches the `app` value in `fly.toml` (default:
   `prediction-market`).
3. Create a persistent volume for SQLite (size can be adjusted, region set to `cdg`):
   ```bash
   fly volumes create data --size 1 --app prediction-market --region cdg
   ```
4. Deploy using the bundled Dockerfile (this repository already includes
   `fly.toml`, so you do **not** need to run `fly launch`):
   ```bash
   flyctl deploy
   ```
   The service listens on `0.0.0.0:8000` as required by Fly.
5. After deploy, verify:
   - App UI: `https://<your-app>.fly.dev/`
   - API docs: `https://<your-app>.fly.dev/docs`

The included `fly.toml` mounts `/data` and sets `DATABASE_URL` to
`sqlite:////data/prediction.db` with `RESET_DB_ON_STARTUP=false` so your data is
kept between restarts.

### Frontend build notes

- The frontend lives in `app/frontend` (React + TypeScript + Tailwind, built with Vite).
- Local dev: `npm run dev -- --host` (set `VITE_API_BASE_URL` to point at your FastAPI server).
- Production: `npm run build` writes to `app/frontend/dist`; FastAPI serves that folder automatically, and the Dockerfile builds it in a Node 24 stage before copying into the Python image.

### Fly.io troubleshooting

- If the CLI reports `launch manifest was created for a app, but this is a app`
  while trying to generate a deployment plan, delete any previously generated
  `.fly/` folder and rerun `flyctl deploy` (not `fly launch`) to rely on the
  included `fly.toml`.

## Key API flows

- **Create a user** (gets 50€ balance): `POST /users` with `{ "name": "alice" }`.
- **Top up a user**: `POST /users/{id}/deposit` with `{ "amount": 10 }` to simulate manual balance credits.
- **Inspect positions**: `GET /users/{id}/positions` summarizes held shares and implied odds per market/side.
- **Create a market**: `POST /markets?user_id=<creatorId>` with `MarketCreate` payload. The creator is debited 10€ to seed the AMM. Use `liquidity_b` to tune price sensitivity.
- **Place a bet**: `POST /markets/{id}/bet?user_id=<id>` with `{ "side": "YES" | "NO" }` for a fixed 1€ stake. Rate limited to one bet per market every 5 seconds globally.
- **Check markets**: `GET /markets` or `GET /markets/{id}` for prices, odds, and bets.
- **Resolve**: `POST /markets/{id}/resolve` with `{ "outcome": "YES" | "NO" | "INVALID" }`. Winners are paid `shares * 1€`; invalid markets refund all stakes and return the seed.
- **Complaints**: `POST /markets/{id}/complain` while status is `PENDING` to log disputes.
- **Ledger**: `GET /users/{id}/ledger` shows `STARTING_BALANCE`, `DEPOSIT_SEED`, `BET_DEBIT`, `PAYOUT`, and `REFUND` entries.

## Risk controls & pricing guardrails

For a deep dive into pricing math and guardrails, read [docs/odds.md](docs/odds.md).

- **Probability clamps**: Markets must launch between 10% and 90% initial probability, and live odds stay within that band (bets on YES are blocked at/above 90%, bets on NO at/below 10%).
- **Creator loss cap**: The AMM will not mint shares that could pay out more than the 10€ seed + all collected stakes if the market resolved immediately. Excessively dilutive bets are rejected with an error.

## AMM implementation notes

- Uses the LMSR cost function with configurable `b`. Initial `q_yes/q_no` are set so the price matches the creator's probability and the AMM is pre-loaded with a 10€ subsidy (shifted equally across quantities).
- Each 1€ bet solves for the share delta such that `C(q') - C(q) = 1`. Stored shares lock in the payoff; displayed odds are `shares / stake`.
- Prices are always derived from current `q` via LMSR and exposed as `price_yes`/`price_no` on market reads.

## Frontend suggestion

For a lightweight UI, run the FastAPI docs or pair this backend with a small React/Vite single-page app that calls these endpoints; host both on services like Render/Fly.io with SQLite persisted to disk or swapped for Postgres.
